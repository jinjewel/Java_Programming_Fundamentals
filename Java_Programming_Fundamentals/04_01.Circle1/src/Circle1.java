// 실세계 객체마다 고유한 특성과 행동을 가지고, 서로 상호작용을 하면서 존재

// 객체 지향 특성 : 캡슐화
// 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는것, 외우의 접근으로 부터 객체를 보호하기 위해

// 클래스(class): 객체 모양을 선언한 틀(캡슐화)
// 메소드(멤버 함수)와 필드(멤버 변수)는 모두 클래스 내에 구현
// 객체를 만들어 내기 위한 설계도 혹은 틀

// 객체
// 클래스 모양대로 생성된 인스턴스(instance)
// 객체 내 데이터에 대한 보호, 외부 접근 제한
// 클래스의 모양 그대로 찍어낸 실체
// 메모리 공간을 갖는 구체적인 실체
// 인스턴스라고도 부름
// 객체들은 클래스에 선언된 동일한 속성을 가지지만 객체마다 서로 다른 고유한 값으로 구분됨

// 객체 지향의 특성 : 상속
// 상속 : 상위 개체의 속성이 하위 개체에 물려져서 하위 객체가 상위 개체의 속성을 모두 가지는 관계
// 예) 사람은 동물의 속성을 다 가지고 있지만 나무는 동물의 속성을 가지고 있지 않다.
// 생물 -> 동물 -> 사람, 생물 -> 식물 -> 나무
// 부모 클래스 : 수퍼클래스
// 하위 클래스 : 서브클래스, 수퍼 클래스를 재사용하고 새로운 특성 추가

// 객체 지향의 특성 : 다형성
// 다형성 : 같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현, 메소드 오버로딩과 메소드 오버라이딩이 해당
// 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 여러 메소드
// 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현, 부모클래스의 함수를 수정하여 사횽하는 방법, 재정의

// 객체 지향 언어의 목적
// 소프트웨어의 생산성 향상 : 컴큐터의 산업 발전에 따라 생명 주기 단축, 객체 지향 언어
// 소프트웨어를 빠른 속도로 생산할 필요성이 커지며, 
// 재사용을 위한 여러 장치(상속, 다형성, 객체, 캡슐화)가 생기므로 다시 만드는 부담이 줄고 생산성 향상됨.
// 실세계에 대한 쉬운 모델링 : 컴큐터 초기시대의 프로그래밍, 현대 프로그래밍, 객체 지향 언어
// 옛날에는 처리 과정, 계산 절차에 초점을 두었다면 현재는 객체등의 상호작용을 묘사하는 것이 더 중요해졌다.
// 실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

// 절차 지향 프로그래밍
// 순서로 표현, 함수들의 집합으로 작성

// 객체 지향 프로그래밍
// 객체들간 상호작용으로 표현, 클래스 혹은 객체들의 집합으로 작성

// public 다른 클래스들에서 Circle 클래스를 사용하거나 접근할 수 있음을 선언
public class Circle1 {
	
	int radius; // 원의 반지름 멘버변수(필드)
	String name; // 원의 이름 멘버변수(필드)
	
	// 원의 생성자, 멘버 함수
	// 생성자 : 객체가 생성될때 초기화를 위해 실행되는 메소드
	// 기본 생성자 : 매개 변수 겂고 아무 작업 없이 단순 리턴하는 생성자(디폴트 생성자라고 부르기도 함)
	// 클래스에 생성자가 하나라도 작성된 경우 기본생성자는 자동 삽입되지 않음.
	public Circle1() { }  // 생성자 메소드(멤버 함수)
	
	public double getArea() { // 원의 면적 계산 메소드(멘버 함수)
		return 3.14*radius*radius;
	}
	
	// static 때문에 따른 파일에서 불러올시 참조를 못함
	// public 다른 모든 클래스의 접근을 허용
	public static void main(String[] args) { 
		
		// 반드시 new로 레퍼런스 Circle 타입의 객체(변수)선언
		// 객체를 선언할 때 반드시 new 키워드 이용
		// 객세 생성과정 : 객체에 대한 레퍼런스변수(주소변수) 선언, 메모리 할당, 객체내 생성자코드 실행 
		Circle1 pizza;
		pizza = new Circle1();
		pizza.radius = 10; 
		pizza.name = "자바피자"; 
		double area = pizza.getArea(); 
		System.out.println(pizza.name + "의 면적은 " + area);
		
		// 반드시 new로 레퍼런스 Circle 타입의 객체(변수)선언
		// 객체를 선언할 때 반드시 new 키워드 이용
		Circle1 donut = new Circle1(); // 반드시 new로 레퍼런스 Circle 타입의 객체(변수)선언
		donut.radius = 2; 
		donut.name = "자바도넛"; 
		area = donut.getArea();
		System.out.println(donut.name + "의 면적은 " + area);
	}
}

// 출력
// 자바피자의 면적은 314.0
// 자바도넛의 면적은 12.56